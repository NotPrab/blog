 # Eazfuscator.NET Virtual Enclosure Reduction Method  -- by [Jemmy Wang (JemmyLoveJenny)](https://github.com/JemmyLoveJenny)
 ## Preamble
The reason I started analyzing Eazfuscator is really odd....
Eazfuscator is a protective shell for a .Net program, and according to @Kido and @wwh1004 Big God, this shell is kind of the stronger one....
It's really a shame to say, I had Eazfuscator.NET 2018.1 cracked in my computer a long time ago, but I didn't realize that Eazfuscator was a strong shell and had always just used its default mode (as if there was string encryption and name confusion) and didn't find anything special about it.
The first day of May, the hand bitch to upgrade VisualStudio to 2019 version, Eazfuscator must also be upgraded to 2019.1. No Eazfuscator activation code, so I thought of the Spring Festival when Kido released the Eazfuscator Keygen ([click here](https://www.52pojie.cn/thread-860680-3-1.html)), read the post to know that Eazfuscator also IL level virtualization protection!
At that time, my user group wasn't enough and I didn't have the right to download it, so I posted a post on the Essence to earn points. After enough points, I finally downloaded Keygen... but the registration code generated by Keygen is not valid for version 2019.1...! I'm really tired... I guess the parameters need to be changed when the registration code is generated, just think about changing Kido's Keygen! Yet Keygen is also protected by Eazfuscator's IL virtualization....
So I went down the road of no return to restore Eazfuscator protection, starting with activating Eazfuscator....

## Analysis tools

Software: just dnSpy is enough! One more ILSpy can also be opened against dnSpy. (or open the attached il in Notepad++)

Net platform, otherwise it's useless to restore virtual machine protection.

## Update Notes.
The results of the research written in the article so far are sufficient to analyze the virtualized IL protection of Eazfuscator.NET. 
Changes will be updated in the article if new research becomes available in the future.

## Eazfuscator.NET Protection Introduction
I hadn't found IL-level virtualization protection before because I hadn't read the documentation for Eazfuscator. 
Now that I've read the document twice over, I'd like to introduce a few of the main protections that Eazfuscator uses. 
Don't spray me ORZ if you're wrong... The following examples can be found in UnpackMe, you can dnSpy the confused UnpackMe and ILSpy the unconfused UnpackMe.

## Name Protection
This is the most basic operation of .Net protection... all the class names, method names, and variable names in the code are confused into meaningless strings, 
so that one cannot directly see what the code does. I won't give you an example of that.

## Encryption
Encrypts data such as strings, numbers, arrays, etc. and restores them during runtime. For example
```csharp
// UnpackMe1.MainForm
private void BtnStringEncryption_Click(object sender, EventArgs e)
{
	MessageBox.Show("The strings in this method is encrypted!", "String Encryption", MessageBoxButtons.OK, MessageBoxIcon.None);
}
```
Encrypted to
```csharp
// UnpackMe1.MainForm
private void BtnStringEncryption_Click(object sender, EventArgs e)
{
	MessageBox.Show(\u0003\u2004\u2001.\u0002(2084363179), \u0003\u2004\u2001.\u0002(2084362362), MessageBoxButtons.OK, MessageBoxIcon.None);
	if (6 == 0)
	{
	}
}
```
### IL Virtualization Protection
This protection is the focus of the analysis in this article. This protection is somewhat similar to IL code interpretation enforcement, which is still IL in nature, so let's put in a bit of code to get a feel for it.
The original code was this, a simple call
```csharp
// UnpackMe1.MainForm
private void BtnCallVirtualization_Click(object sender, EventArgs e)
{
	MessageBox.Show("Leave CallVirtualization");
	BtnVirtualization_Click(sender, e);
	MessageBox.Show("Back to CallVirtualization");
}
```
Virtualization
```csharp
// UnpackMe1.MainForm
private void BtnCallVirtualization_Click(object sender, EventArgs e)
{
	object[] array = new object[3];
	object[] array2;
	if (-1 != 0)
	{
		array2 = array;
	}
	array2[0] = this;
	array2[1] = sender;
	array2[2] = e;
	\u0002\u2007 u0002_u = \u0006\u2004\u2001.\u0002\u2005\u2001();
	Stream u = \u0006\u2004\u2001.\u0003\u2005\u2001();
	string u2 = "@]iC5AnPXc";
	object[] u3 = array2;
	if (!false)
	{
		u0002_u.\u0002(u, u2, u3);
	}
}
```
Oh, this protected code pro-mother doesn't even know.....

### Codeword
Kido said in his post that Eazfuscator's activation algorithm is out of order and not virtualized, and Eazfuscator's documentation also says *"Code Control Flow Obfuscation "*, 
but it doesn't seem to me that it makes any difference whether it's out of order or not... I don't feel that code obfuscation exists or works.
It must be said that there is disorder, then one can only assume that the dynamic debugging analysis method directly ignores disorder....

## EazFuscator.NET (reverser thoughts)
The Eazfuscator's protection isn't as strong as it's rumored to be, but the protection is a bit stronger than the average shell.
I don't think it's possible to fully revert to the original IL, nor is it easy to modify the code flow (e.g. directly return true)
Anyway, Eazfuscator is also a virtual machine shell, so don't think that the whole program can be taken out completely, we just need to analyze the code flow of the key parts.

I don't know much about the idea of restoration, but many of the methods come to me in a flash.
I can only bring up one or two points of general thought, if you can't understand it, just reply and ask me!

### Dynamic debugging is better than static analysis
Both IL and PE virtual shells have similar effects, with very high interference for static analysis and less impact on dynamic debugging.

I've tried static analysis before (look directly at the code in dnSpy), looking at each function call and analyzing the effects. That's disgusting... The code uses a lot of interfaces, abstract classes, delegate this kind of stuff, that is to say, see the call function only a declaration, static analysis is difficult to see the real function body, there is no way to start.
The mere deciphering of data such as strings can baffle people.

After using dynamic debugging, I feel much better (although it's still disgusting)... Sometimes, by looking at the input and output of the method, you can get a general idea of what it does, without having to look at the code one by one. And the encrypted strings are automatically decrypted when they run, so we just cut them off at the breakpoint!

And looking at the changes in local variables can also enlighten and help us in our analysis when we're initially unthinking, direct dnSpy single-step execution.

### Reverser thoughts to find the key breakpoint
Let's imagine that if I were the author of the Eazfuscator virtual machine case, how would I run the virtualized code?
I'll write a random piece of code.
```
public bool IsActivated(string serial) {
	byte[] EncryptedData = Convert.FromBase64String(serial);
	byte[] DecryptedData = dESCryptoServiceProvider.CreateDecryptor().TransformFinalBlock(EncryptedData, 0, EncryptedData.Length);
	return Encoding.ASCII.GetString(DecryptedData) == "AAAAA";
}
```
There are many method calls in this code, such as FromBase64String, TransformFinalBlock, GetString
Net Framework should not be virtualized, so the virtualized code will definitely call these methods.
Then use dnSpy's analytics feature to analyze where these methods are called
I know I use DESCryptoServiceProvider in my UnpackMe, so let's do a white box test and analyze it!
Drag UnpackMe1.exe(I won't be able to find his target sorry < 3) into dnSpy-x86 (the non-x86 one cannot be debugged), find the System.Security.Cryptography namespace in mscorlib.dll, and analyze the DESCryptoServiceProvider in it.
![](https://camo.githubusercontent.com/b1fa034a71d462d33f7e38ada22505eb49420f19/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f416e616c797a652d44455343727970746f5365727669636550726f76696465722e706e67)
EMMM? and it's not being used? Is it dnSpy gone wrong? Is there a way to call a function without the parser noticing it?
Net has an amazing feature - Reflection!
[Kids who don't know much about Reflection click here](https://blog.csdn.net/caosiyuan1991/article/details/19172755)
If Reflection is used, Reflection can be analyzed, because even if Reflection is virtualized, it is still Reflection.
So let's try again and choose MethodInfo for Reflection.
![](https://camo.githubusercontent.com/f46d82cd5c56dae969e250d9222f41946fa10d59/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f416e616c797a652d4d6574686f64496e666f2e706e67)
Those \u000x\u000x name methods inside the analyzer are methods related to virtualization calls.

## Virtual IL Restore - Basic Method (General enough)
Next I describe my initial approach to analyzing the IL virtual machine. Think of yourself as a relatively simple and effective method. If you masters have better ideas, I hope you can bring them up and teach me......

UnpackMe has four buttons.
StringEncryption: Just decrypting a string and popping a window, for testing breakpoints.
VirtualizedForm: pops up a virtualized window and lets everyone analyze the flow of window string generation.
Virtualization: Enter the registration code in the text box above, click the button to verify that the registration code is correct and that the code is protected by virtualization.
CallVirtualization: Call the Virtualization handlers with virtualization code, for analyzing the call stack.

### Dynamic debugging first try (the master skips it)
The first try is to try to break points, look at local variables, and take the simplest string decryption.......
Open Dnspy UnpackMe1.MainForm.BtnStringEncryption_Click(object,EventArgs)  Methods.
```
private void BtnStringEncryption_Click(object sender, EventArgs e)
{
	MessageBox.Show(\u0003\u2004\u2001.\u0002(2084363179), \u0003\u2004\u2001.\u0002(2084362362), MessageBoxButtons.OK, MessageBoxIcon.None);
	if (6 == 0)
	{
	}
}
```
As can be seen, Eazfuscator was called \u0003\u2004\u2001.\u0002(int) to get the decrypted string
So the breakpoint of the return of \u0003\u2004\u2001.\u0002(int) can intercept the string directly. (128 lines)
The next breakpoint is the same as in VisualStudio, just click on the code line number to the left.......
Then the point above starts and the program breaks down several times, producing some strings related to MainForm initialization.
Click the StringEncryption button and the broken string will be the MessageBox Text and Caption respectively.

### Call method breakpoint (breakpoint recording method)
I won't go into that much detail next....or the article won't be finished.
The code is very scattered, so it's not convenient to paste the code. If you want to understand it, it's best to open dnSpy and do it yourself
Let's go to the Virtualization button.
![](https://camo.githubusercontent.com/93beb3cf5e7b41a8d7037c838698da796b5975a7/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f42746e5669727475616c697a6174696f6e5f436c69636b2e706e67)
Analysis of virtualized code needs to be focused, for example.
One-step debugging can tell what really works in the above code is
```
u0002_u.\u0002(u, u2, u3);
//方法签名为\u0002(Stream, string, object[]):void
```
We can guess that Stream is the virtual instruction stream, string is the instruction stream decryption key and the like, and object [] is the method parameter (including this, sender, eventArgs). Our focus is on the execution part of the virtual code, so we can ignore the instruction Stream Stream u generation process, ignore the executor \ u0002 \ u2007 u0002_u generation process, put your mind on the u0002_u. \ U0002 (u, u2, u3); method that actually executes the instruction

This is important! ! ! I didn't think of Reflection at first, but I focused on the key to find the location of the key breakpoint.

It is really simple to set a breakpoint at the calling method, because now I know that the calling will use Reflection, and I have learned from experience that several key functions related to calling use MethodBase.IsConstructor. Therefore, we can use the analyzer to analyze the usage of (mscorlib.dll) System.Reflection.MethodBase.IsConstructor.get () to find the key functions. 
![](https://camo.githubusercontent.com/855d0bd4de4c9435b66b4f2ef8efb0c40f6c7e4d/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f416e616c797a652d4d6574686f64426173652e4973436f6e7374727563746f722e706e67)
At the beginning, you can add more breakpoints, add method breakpoints to all 4 methods found by the analyzer (the next one at the function entry and exit, a total of 8 breakpoints), and then repeat the function or break the unwanted Just click and delete. I ended up keeping 2 of the 8 breakpoints
```
\u0002\u2007.\u0002(MethodBase, object, object[]) : object + 0x0000 (入口处)

\u0002\u2007.\u0002(MethodBase, bool) : \u0002\u2007 + 0x2B7 (出口处)
```
There is another place that is more critical, which I also found after stepping through the debugging
```
(mscorlib.dll)System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(object, object[], object[]) : object + 0x0039 (出口处)
```
I have a Breakpoints.xml in my attachment. Children's shoes with wrong breakpoints can be imported into my breakpoints by dnSpy to experience it.

After finishing the breakpoint or importing the breakpoint, the breakpoint window is as follows: 
![](https://camo.githubusercontent.com/a5e0163cd7bc69e8a4c784cd920122b7f36870c1/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f427265616b506f696e74732d53696d706c652e706e67)
just look at the three checkpoint activated breakpoints. Other breakpoints are used in advanced methods.

After the breakpoint is finished, start debugging again, enter something in the input box (I lost AAAAA), click Virtualization, and the program will be broken by dnSpy. 
![](https://camo.githubusercontent.com/1b7f26546845387d7909c36f0ca09b2e5dc2a44f/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f42502d312e706e67)
Figure \ u0002 MethodBase method is now called, and then press to continue 
[](https://camo.githubusercontent.com/e62e269b59404d42569fd1530def2594117b3a02/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f42502d322e706e67)
you can see the results of that call u4

Then keep pressing Continue. After summing up, you can know the meaning of the local variables at each breakpoint:
```
//\u0002\u2007.\u0002(MethodBase, object, object[]) : object + 0x0000 (入口处)

\u0002 目标方法(要调用的函数)MethodBase
\u0003 非静态方法的this
\u0005 向目标方法传递的参数
```

```
//\u0002\u2007.\u0002(MethodBase, bool) : \u0002\u2007 + 0x2B7 (出口处)

\u0002 目标方法(要调用的函数)MethodBase
obj 非静态方法的this
array5 向目标方法传递的参数
u4 方法调用后的返回值
```

```
//System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(object, object[], object[]) : object + 0x0039 (出口处)

this 目标方法(要调用的函数)MethodBase
obj 非静态方法的this
arguments, parameters 都是参数，暂未发现区别
```

Every time the breakpoint records the collected information and then reverses the code even with a guess , for example, Virtualization continues all the way, and the record is as follows (MethodBase, parameters, this, return value combined analysis, if this is not null, Instance is added when I record):

```
textBox.Instance.get_Text();
data=Base32Decode(text); //这里有点难，名字被混淆了，根据MethodBase的FullName找到目标函数，看一眼代码能分析出是Base32
new DESCryptoServiceProvider();
InitializeArray(new byte[8] { 0x1F, 0x28, 0x87, 0x08, 0xCC, 0x32, 0x22, 0x35 }, RuntimeFieldHandle);
DESCryptoServiceProvider.Instance.SetKey(new byte[8] { 0x1F, 0x28, 0x87, 0x08, 0xCC, 0x32, 0x22, 0x35 });
InitializeArray(new byte[8] { 0xE2, 0xA2, 0x83, 0xBE, 0x99, 0x76, 0x84, 0x38 }, RuntimeFieldHandle);
DESCryptoServiceProvider.Instance.SetIV(new byte[8] { 0xE2, 0xA2, 0x83, 0xBE, 0x99, 0x76, 0x84, 0x38 });
DESCryptoServiceProvider.Instance.CreateDecryptor();
CryptoAPITransform.Instance.TransformFinalBlock(data);//这里的this是上一步骤CreateDecryptor()的返回值；此步骤报错，解密出错
```

The above is just pseudo code, and then rewrite it according to the syntax:

```
string serial = tbInput.Text;
byte[] bEncryptedData = Base32.FromBase32String(serial);
DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
cryptoServiceProvider.Key = new byte[8] { 0x1F, 0x28, 0x87, 0x08, 0xCC, 0x32, 0x22, 0x35 };
cryptoServiceProvider.IV = new byte[8] { 0xE2, 0xA2, 0x83, 0xBE, 0x99, 0x76, 0x84, 0x38 };
byte[] bDecryptedData = cryptoServiceProvider.CreateDecryptor().TransformFinalBlock(bEncryptedData, 0, bEncryptedData.Length);
```

It is very clear and clear. The actual operation of Virtualization is to get input. After Base32 decoding, it uses the set Key and IV to decrypt with DES. Because the data entered randomly is invalid, the decryption is wrong. As for converting the registration code verification code into a registration code generation code, that is not the subject of this article ... Provide several sets of registration codes: the first 5 are valid, the last 3 are invalid, but the error location is different
```
1 Of 5     	WYYCZJM7UUNXNLWPGWTYG89S73
2 Of 5     	8S9BZUVPPMY9J5FRYDZXXHXJL5
3 Of 5     	UVGD4CC2NMD63RA5HG6EPAAWU9
4 Of 5     	W6W5LE28GNBF5ANR3UPJTKRXP2
5 Of 5     	76WWW7Z2VXUQMVCB38CXFG9W55
N Of 5     	TUYD94XEX4UR8R26MECH78FUE8
WrongLength	TUYD94XEX4URQXEGBP46943AS3
Invalid    	AAAAAAAAAAAAAAAAAAAAAAAAAA
```
With a valid registration code, you can continue to analyze without reporting errors. If you continue to analyze the process afterwards, you will encounter string decryption and call a System.String (Int32) MethodBase. The returned string is the key, and the incoming parameter Int32 can be ignored. (The function to decrypt the string is \ u0003 \ u2004 \ u2001. \ U0002, which may not be displayed completely in the local variable window, because \ u0000 these are non-visible characters of Unicode)

The only information that can be obtained by the breakpoint recording method is MethodBase, parameters, this, and return value . Other operations need to rely on your analysis and association. As long as the return value of which call is correctly guessed and analyzed, and becomes one of the parameters of which call, the virtual code executed by the program can be restored.

The result of decrypting the string with different registration codes is different, and the pop-up characters are also different. Why? Because I added if and switch these two judgment statements in the following process. Different judgment results will jump to different branches. The breakpoint recording method can only let us know the flow of the branch that the program is currently running, and the branch jump is not known by the breakpoint recording method, which is also a disadvantage of the breakpoint recording method. If you want to know the information of branch jump, you must use advanced methods.

To summarize the breakpoint recording method:

Key points:
> The analyzer looks for the function that uses (mscorlib.dll) System.Reflection.MethodBase.IsConstructor.get () to intercept 4 pieces of information (MethodBase, parameter, this, return value) at the function entry exit System.Reflection.RuntimeMethodInfo. UnsafeInvokeInternal (object, object [], object []): The breakpoint at the exit of the object correctly even restores the code with a guess.

advantage:
> As long as the breakpoints and records are recorded, the operation is simple enough for most cases where there is no branch jump (I used the breakpoint recording method to restore Kido's Keygen)

Disadvantages:
> If the analysis ability is not enough, it may be wrong to analyze, and it is difficult to analyze the non-calling statements, such as judgment statements (if, switch, etc.) by guessing the restoration code. …),

## Virtual IL Restore-Advanced Method (IL Restore Method)
Eazfuscator's IL virtual machine execution method is very similar to that of .Net CLR. If you have enough time and energy, you can switch from the virtual IL of Eazfuscator to the normal IL of .Net. The advanced method is more complicated and requires a better understanding of .NetCLR operation

### .Net CLR execution method

#### IL instruction (OpCodes)
There is a detailed introduction about OpCodes on MSDN ![Click Here]( https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.emit.opcodes?view=netframework-4.8#%E5%AD%97%E6%AE%B5) (Opcodes, OpCodeType, OperandType are recommended to take a look at all three chapters) You do n’t need to be familiar with all OpCodes, but you need to know what it means to use common IL. Especially those IL instructions related to branch jumps.

One thing to note is that the parameters of IL, the instruction may have different types of parameters, some IL has no parameters, such as add , ldc.i4.0 , ldloc.0 , stloc.0 , br.s, some IL has int8 parameters, such as ldc .i4.s , ldloc.s , stloc.s and some IL with int16, int32, int64, float32, float64 and even some IL with strange types of parameters, such as call , box.
#### .Net CLR stack (data flow direction)
![](https://camo.githubusercontent.com/856b7b4ba76c33d4d8ad849827590e2b31298afc/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f434c522d4f766572766965772e706e67)
You must first know a few stacks of .Net CLR execution when IL PE program and the stack of different stack, it is not for the existence of the real CPU stack, just a CLR abstract out the logic stack managed by the CLR.

In fact, FunctionParameters and LocalParameters are not in the first-come-first-out format, which is not a stack in the general sense. I do n’t know what to call it. Just think of them as a place to store data.

##### Evaluation Stack

The middle one in the figure above is EvaluationStack, which is also the most important stack when .Net is executed. The execution of all instructions is related to EvaluationStack.

When method A calls method B, the .Net program will push arg0 (this in non-static methods), arg1, ..., argx into the stack in sequence. When method B returns, the only data in EvaluationStack (only 0) Or 1) is pushed into the Evaluation Stack of Method A

All calculation operations take place in EvaluationStack

##### Function Parameters

FunctionParameters seems to belong to a part of CallStack, but I do n’t know ... I just said that according to my own understanding, the one on the far right side of the picture is Function Parameters, which stores the parameters passed when calling this method. When the method A calls the method B, the parameters of the EvaluationStack pushed into A will be popped up in turn. Enter the Function Parameters of method B. Method B will push the corresponding parameters in FunctionParameters into the method's own EvaluationStack through ldarg.1, ldarg.s, etc

##### Locals Variables

LocalsVariables also seems to be part of CallStack, and I can't tell clearly ... The leftmost one in the above picture is LocalsVariables. This is easy to understand. It is a place where variables are temporarily stored. The size, such as UnpackMe1.MainForm.BtnVirtualization_Click of UnpackMe1.clear.exe, has the following .locals definition

```
.maxstack 4
.locals init (
	[0] uint8[],
	[1] class [mscorlib]System.Security.Cryptography.DESCryptoServiceProvider,
	[2] uint8[],
	[3] uint8
)
```
This IL has limited the number and type of LocalsVariables of this method.

Method: Use stloc.0, stloc.s, etc. to save the data popped by EvaluationStack into LocalVariables; use ldloc.0, ldloc.s, etc. to push the data of LocalVariables into EvaluationStack. Note that ldloc will not delete the LocalVariables data, but stloc will pop up the EvaluationStack data

##### .Net CLR operation
The actual operation is actually a bit complicated, and it needs to be compiled into native code by the JIT compiler for execution. But we can ignore those and understand that the CLR interprets execution. In this case, the operation process is actually quite simple ... The content of the CLR operation is, in the final analysis, a series of IL instruction streams. It is conceivable that when the CLR enters a method, it will get a stream of instruction streams of the method. The CLR first allocates LocalsVariables according to .locals and prepares FunctionParameters. The execution process is to continuously read the Stream to obtain instructions, and then operate three stacks or jumps according to the instructions (jump is equivalent to the Seek instruction Stream, reset the read position), and then repeat the above execution process, The calculation result is returned until the ret instruction is encountered.

### Analogy of concepts in .Net CLR to Eazfuscator
Eazfuscator's IL virtualization protection, the actual command is still the IL command. If you want to run it, you must imitate the execution method of .NetCLR, so after understanding from .Net CLR, you can analogy to Eazfuscator.

#### Find the virtual CLR of Eazfuscator.NET
This CLR is definitely a class, it cannot be a separate method. In fact, it ’s easy to find, all kinds of clues point to a class \ u0002 \ u2007

In the breakpoint recording method, two of the next three breakpoints are in \ u0002 \ u2007. In the virtualized MainForm.BtnVirtualization_Click (), something like \ u0002 \ u2007 is also generated.

This strange \ u0002 \ u2007 is the virtual CLR of Eazfuscator.

#### Find the place where the run command is generated
The instruction stream must be cycled Read, and only the instructions to be executed can be executed, right? Then we will find this looped place next. It is enough to use the three breakpoints set in the breakpoint recording method first. After any input, click Virtualization. After the breakpoint is broken, we look at the call stack (toolbar-debug-window-call stack) 
![](https://camo.githubusercontent.com/abfad6d2add7db9fbea852ffaa10086b587dcdd2/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f43616c6c537461636b2d312e706e67)
and then we start from look down on one by one, until here 
![](https://camo.githubusercontent.com/6badc19407b02bc7f4beef1fc97cdf2e74f13c56/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f43616c6c537461636b2d322e706e67)
we have found a loop, although it can not read a specific role, but there really is a cycle instruction execution, the local virtual IL continuous operation. \ u0002 \ u2007. \ u0005 (bool): void This is a sign of a virtualized function, and every virtualized function will run here. The number of functions in the call stack also reflects the number of virtualized call levels. For example, when you click Virtualization, we see that the number of \ u0002 \ u2007. \ U0005 (bool): void in the call stack is always only one. But click on CallVirtualization, after the MessageBox pops up "Leave CallVirtualization", click a few times to continue, you can see the call stack quickly expands, there are two layers \ u0002 \ u2007. \ U0005 (bool): void, as shown in the figure: 
[](https://camo.githubusercontent.com/32a396ce7e9aebf0f2777ab1edc42d5a984c63e7/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f43616c6c537461636b2d332e706e67)

Then follow this step by step step by step debugging, you can find other analogy things.

##### Eazfuscator.NET virtual CLR stack (data flow direction)

###### Data packaging type

The data in the Eazfuscator stack has been packaged. The basic type of data packaging is \ u0002 \ u2001, and then it has several derived types, as shown in the figure: 
![](https://camo.githubusercontent.com/09fadc4c7a9748706c3115ca99601b65a296c2b6/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f753030303275323030312e706e67)
These derived types are used to wrap different basic types, such as:

| Data packaging class name | Storage data type |
| - | - |
| \u0002\u2003 | byte |
| \u0002\u2004 | long |
| \u0002\02005 | uint |
| \u0003\u2002 | Enum |
| \u0005\u2001 | Array |
| \u0005\u2003 | short |
| \u0005\u2005 | ulong |
| \u0005\u2006 | UintPtr |
| \u0005\u2009 | string |
| \u0006\u2001 | bool |
| \u0006\u2005 | MethodBase |
| \u0006\u2009 | object |
| \u0008\u2002 | double |
| \u0008\u2004 | sbyte |
| \u000E\u2002 | float |
| \u000E\u2003 | int |
| \u000E\u2004 | ushort |
| \u000F\u2001 | char |
| \u000F\u2005 | IntPtr |
| \u000F\u2006 | object (used to store any other type) |

##### Evaluation Stack
This EvaluationStack is handled strangely ... The EvaluationStack is divided into three parts, the stack is from top to bottom \ u0003 \ u2003, \ u0008 \ u2001, \ u0005 \ u2001 When the data is pushed into EvaluationStack, all of the stack The data will move from top to bottom in sequence. Move backward when it pops up.

##### FunctionParameters
\ u000F \ u2000 is an array, \ u000F \ u2000 [x] in the array is the x of ldarg.x. Note that in non-static methods, arg.0 is this, not the first parameter!

##### LocalsVariables
LocalVariables are all stored in \ u0005, \ u0005 [x] is the x of ldloc.x

#### Eazfuscator.NET virtual CLR variable meaning
The idea of ​​discovering the specific meaning will not be elaborated ... it is really unclear. The main idea is to compare the IL code of clear.exe with the change of CLR local variables of obfs. The other is to use the analyzer to analyze the relationship between the various functions. We break at any of the breakpoints in \ u0002 \ u2007, and then expand this to see the result as follows: 
![](https://camo.githubusercontent.com/2f1d94a310d3f43c2c4cda71c6616e8ba80a2a2e/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f753030303275323030372e706e67)

|Type of local variables | Name of local variable | Local variables|
| - | - | - |
| bool | \u0002\u2000 | <unknown> |
| \u0003\200A | \u0002\u2002 | <determine>Comparison table of instruction keys and parameter types (explained later) |
| System.Reflection.Module | \u0002\u2004 | <OK>Module currently running (not useful for analysis) |
| \u000E\u2001 | \u0003 | <unknown> |
| \u000E\u2001 | \u0003\u2000 | <conjecture>Readers created from the \u0006\u2003 command array |
| System.IO.Stream | \u0003\u2001 | <guess>incoming instruction (data) stream Stream |
| \u0002\u2001 | \u0003\u2003 | <determine>EvaluationStack |
| System.Collections.Generic.Stack<\u0002\u2007.\u0008> | \u0003\u2004 | <unknown> |
| \u0002\u2001[] | \u0005 | <determine>LocalsVariables |
| System.Collections.Generic.Stack<\u0002\u2001> | \u0005\u2001 | <determine>EvaluationStack |
| \u0008\u2000 | \u0005\u2002 | <Determine> Some information about the method that is currently running |
| uint | \u0005\u2003 | <OK> Next instruction (data) position (instruction pointer) |
| long | \u0005\u2004 | <unknown> |
| System.Type[] | \u0006 | <unknown> |
| object | \u0006\u2000 | <unknown> |
| System.Type[] | \u0006\u2002 | <unknown> |
| byte[] | \u0006\u2003 | <Determine> instruction (data) flow arrays |
| uint | \u0008 | <OK> Length of instruction (data) stream array |
| System.Type | \u0008\u2000 | <Unknown> |
| \u0002\u2001 | \u0008\u2001 | <OK> Part of EvaluationStack |
| System.Collections.Generic.Stack<\u0002\u2007.\u0006\u2000> | \u0008\u2003 | <Unknown> |
| \u0008\u2009[] | u000E\u2000 | <Unknown> |
| uint? | \u000E\u2001 | <OK> branch jump target |
| object[] | \u000E\u2002 | <Unknown> |
| uint | \u000F | <OK> Current running instruction (data) location (from \ u0005 \ u2003) |
| \u0002\u2001[] | \u000F\u2000 | <OK>FunctionParameters |
| bool | \u000F\u2001 | <OK> return flag (return) |

Although the meaning of many variables in the virtual CLR is unknown, but this does not affect the process of our analysis ... The variables we already know are enough to restore the IL code. The rest of the variables will try to analyze the meaning when I have time.

#### Eazfuscator.NET virtual IL instruction analysis
We found the above cycle instruction execution place \ u0002 \ u2007 \ u0005 (bool ):. Void but this is not the source of instructions, we carefully look at the code 
![](https://camo.githubusercontent.com/5cd2873c59038ddedaebe8ad32c518a330d3cc59/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f75303030352e706e67)
above judgment with regard to return and branch jump, let's not However, you can find that this. \ U000E () is called every time, so let's take a look. 
![](https://camo.githubusercontent.com/bff0f332c13c9182e67a7bd7f91513a232d45392/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f75303030452e706e67)
This is the point of instruction execution

Take a look at the function of the code, first obtain the \ u0005 \ u2003 instruction pointer, set \ u0005 \ u2003 to \ u000F (see the table above for the meaning of the variable) Then call the \ u0006 () method of \ u0003 \ u2000, the return value is num , Set to key. Then the \ u0005 \ u2003 instruction pointer is increased by 4 (set the position of the next instruction) The last step is to use Dictionary.TryGetValue (key) to get a structure of type \ u0002 \ u2007. \ U0002 \ u2000, call the \ in the structure u0003 method (delegate).

We see that the source of the key is num, and num comes from this. \ U0003 \ u2000. \ U0006 (); where \ u0003 \ u2000 is what, in the above table I am just guessing, then let ’s analyze it and use an analyzer to analyze \ u0003 \ u2000 assignment

Such a string of codes can be found in \ u0002 \ u2007. \ U0002 (object [], Type [], Type [], object []): object:

```cs
\ u0006 \ u2003  u0006_u  =  new \ u0006 \ u2003 ( this . \ u0006 \ u2003 ); \\ Use \ u0006 \ u2003 instruction (data) stream initialization type is u u0006 \ u2003 variable u0006_u 
try
{
	using ( this . \ u0003 \ u2000  =  new \ u000E \ u2001 ( u0006_u )) \\ uses u0006_u just now to initialize the variable of type \ u000E \ u2001 , and set the variable to \ u0003 \ u2000
	{
		this . \ u0008  = ( uint ) u0006_u . \ u0008 \ u2003 \ u2008 \ u200A \ u2005 \ u2004 \ u0002 ();
		 this . \ u000F \ u2001  =  false ;
		 this . \ u000E \ u2001  =  null ;
		 this . \ u000F  =  0u ;
		 this . \ U0005 \ u2003  =  0u ;
		this . \ u0005 ();
		 this . \ u0006 ();
	}
}
```

So you see? \ u0003 \ u2000 is something that contains a stream of data (instructions), so I guess it is a reader created from an array of instructions.

Then go back to the code in the picture above (the following is an excerpt)

```cs
int  num  =  this . \ u0003 \ u2000 . \ u0006 ();
 key  =  num ;
\ u0002 \ u2007 . \ u0002 \ u2000  u0002_u ;
 global :: \ u0002 \ u2007 . \ u0002 . TryGetValue ( key , out  u0002_u );
 u0002_u . \ u0003 ( this , this . \ u0002 ( this . \ u0003 \ u2000 , u0002_u . \ u0002 ));
 ```
 
 Now that we know key = num = \ u0003 \ u2000. \ U0006 (), let ’s put it a bit and wait for a while before continuing the analysis. Look at the last three lines to define a variable u0002_u of type \ u0002 \ u2007. \ U0002 \ u2000, put the result of Dictionary.TryGetValue into this variable. The type of the variable is a structure, as shown in the figure: 
 ![](https://camo.githubusercontent.com/76f50e0a7801aa0a81dfee2ecdaae372a56842f7/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f753030303275323030302e706e67)
 there is a byte, It is called \ u0002 and there is another \ u0002 \ u2007. \ U000F, called \ u0003. \ U0002 \ u2007. \ U000F is a type of delegation, which is defined as follows:
 
 ```
 private delegate void \u000F(\u0002\u2007 \u0002, global::\u0002\u2001 \u0003);
 ```
 
 So the last line will take this and this. \ U0002 (this. \ U0003 \ u2000, u0002_u. \ U0002) as parameters and call the delegate in the structure. What is this, I think everyone already has some understanding, although I do n’t understand the purpose of passing to the delegate ... Then let ’s study another parameter this. \ u0002 (this. \ u0003 \ u2000, u0002_u. \ u0002) In the parameter, this. \ U0003 \ u2000 is the reader, and u0002_u. \ U0002 is the byte in 
 ![](https://camo.githubusercontent.com/09f1190709ef91f4ee14728efd2cb11d629d1a17/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f75303030322d7377697463682e706e67)
 the structure. This method simply and directly switches the byte in the structure. According to different cases, there are different operations.
 
 First look at the code block from case to 0,7, the instruction pointer increases by 4, and the return value comes with \ u000E \ u2003 initialized with \ u0002. \ U0006 (). It ’s time to test memory! What is \ u000E \ u2003? Do you remember? \ u000E \ u2003 is the data package of int! Then \ u0006 () is not familiar? Do you feel familiar? Combined with the incoming parameters, you can find that \ u0002. \ U0006 () is actually this. \ U0003 \ u2000. \ U0006 () Look at the key = num = \ u0003 \ u2000. \ u0006 () Did you find it? \ u0003 \ u2000. \ u0006 () is equivalent to reading 4 bytes from which instruction (data) stream and converting to int (not direct conversion, 4 bytes need to be replaced in order)
 
 The same is true for other cases, the list is as follows:
 
| case | type of data | Read data length | Examples of IL instructions (unexpected question marks) |
|  - | - | - | - |
| 0,7 | int | 4 | call,ldc.i4 |
| 1 | float | 4 | ldc.r4 |
| 2,9 | ushort | 2 | ??? |
| 3 | Array | 4 * (1 + length) | ??? |
| 4,5 | byte | 1 | ??? |
| 6 | long | 8 | ??? |
| 8 | double | 8 | ldc.r8 |
| 10 | null | 0 | add,ldarg.0,stloc.0 |
| 11 | sbyte | 1 | ??? |
| 12 | ulong | 4 | All jump instructions (instruction pointer) |

There are a few points to note!

The first is the ulong read by case12. It stands to reason that ulong takes 8 bytes, and this ulong only uses 4 bytes. Because only jump statement will be used in case12, Eazfuscator knows that the value will not exceed the range of 4 bytes, and the result read by ulong is the instruction pointer of the new branch.

Another point is that the reading order of different types of data is not the same ... For example, there are 4 bytes of data 0xA1,0xA2,0xA3,0xA4 read according to int (case0), then the result is 0xA4,0xA1,0xA2,0xA3 according to ulong (case12) read, then the result is 0xA2,0xA4,0xA1,0xA3

Even if you guess now, you still know what the delegate is ...? The sentence that calls the delegate is the statement that actually works. This delegate points to a function that will operate the three stacks of the virtual machine. 

![](https://camo.githubusercontent.com/d0209ec7789fcf101eccf8d8d961b4e0f137cb52/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f44656c6567617465732e706e67)
The picture shows some functions that may be pointed to by some delegates in \ u0002 \ u2007. Each of these functions is equivalent to an IL instruction.

What I just said is a bit complicated, and the name confusion disrupts the explanation. I will rewrite the important part of the code and read it again. I should understand ...

```cs
// \ u0002 \ u2007. \ u000F (VirtualCLR.OperationDelegate) 
private  delegate  void  OperationDelegate (VirtualCLR \ u0002, DataWrapper \ u0003);

// \ u0002 \ u2007. \ u0002 \ u2000 (VirtualCLR.OpCodeStructure) 
private  struct  OpcodeStructure
{
	public  readonly  byte  operandType ;
	 public  readonly  OperationDelegate  operate ;
}

// \ u0002 \ u2007. \ u000E (): void 
int  num  =  this . DirectiveReader . \ u0006 ();
 int  key  =  num ;
 OpCodeStructure  structure ;
 global :: VirtualCLR . OpCodeDict . TryGetValue ( key , out  structure );
 structure . operate ( this , this . GetOperand ( this . DirectiveReader , structure. operandType ))
 ```
 
 Now that we know that the function pointed to by structure.operate () replaces an IL instruction equivalently, then we now need to analyze the IL statement of each function equivalent replacement

There are many methods this step, I'll give an example: For example, I have static analysis algorithms, or to view the execution stack before and after the change knowing diagram 
![](https://translate.googleusercontent.com/translate_c?depth=1&pto=aue&rurl=translate.google.ro&sl=zh-CN&sp=nmt4&tl=en&u=https://camo.githubusercontent.com/7291dc176e29a9087353b0517c3cab5c0b22e175/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f6c646172672e302e706e67&usg=ALkJrhgbElFVq9CUvXR68Nzc0h3oojT3BA)
of this function is ldarg.0, then u0002 \ u2007.u0003 (x) is quite so we ldarg.x slightly analyzer analyzes u0002 \ u2007.u0003 (x), as shown 
![](https://camo.githubusercontent.com/5bd4d86cd88ac2308745d1955f80da71728efdc1/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f753030303275323030372e75303030332e706e67)
and can follow it to find

```cs
// ldarg.0 
private  static  void \ u0003 \ u2008 (\ u0002 \ u2007 \ u0002 , \ u0002 \ u2001 \ u0003 )
{
	if ( 7  ==  0 )
	{
	}
	\ u0002 . \ u0003 ( 1 );
}
```

```cs
// ldarg.s 
private  static  void \ u0008 \ u2008 \ u2000 (\ u0002 \ u2007 \ u0002 , \ u0002 \ u2001 \ u0003 )
{
	if ( 6  ==  0 )
	{
	}
	if ( 4  ==  0 )
	{
	}
	\ u0002 . \ u0003 (( int ) ((\ u0002 \ u2003 ) \ u0003 ). \ u0002 ()); // Here we need to infer according to the data package \ u0002 \ u2003, we know that the type is byte, that is int8, so Is ldarg.s 
}
```

```cs
// ldarg.3 
private  static  void \ u0008 \ u200A \ u2000 (\ u0002 \ u2007 \ u0002 , \ u0002 \ u2001 \ u0003 )
{
	if ( false )
	{
	}
	\ u0002 . \ u0003 ( 3 );
}
```

```cs
// ldarg 
private  static  void \ u000E \ u2000 (\ u0002 \ u2007 \ u0002 , \ u0002 \ u2001 \ u0003 )
{
	if ( 8  ==  0 )
	{
	}
	if ( false )
	{
	}
	\ u0002 . \ u0003 (( int ) ((\ u000E \ u2004 ) \ u0003 ). \ u0002 ()); // Similarly, according to the data packaging \ u000E \ u2004 back to know that the type is ushort, that is int16, so it is ldarg 
}
```

```cs
// ldarg.2 
private  static  void \ u000F \ u200A \ u2000 (\ u0002 \ u2007 \ u0002 , \ u0002 \ u2001 \ u0003 )
{
	if ( 5  ==  0 )
	{
	}
	\ u0002 . \ u0003 ( 2 );
}
```

I counted, there are about 207 functions that conform to OpCodeDelegate, which is less than 226 Opcodes on MSDN ... I guess it may be because there are no nop, break, etc. These are useless instructions for virtual IL and some load data The instructions such as ldstr are equivalently replaced by ldc.i4 + call; all the jump instructions are to read ulong, no longer distinguish between br and br.s, etc. Of course, it may be that I counted wrong ...

I am curious whether dnSpy can search for functions based on their parameters and return types? Or find all the functions that implement delegate? I did n’t find this function, I know the great gods teach me ... manual counting is too low

In fact, there is no need to analyze and clear the function of each OpCodeDelegate, as long as the analyzed results are enough ... Use dynamic debugging to observe the stack and instruction pointer changes before and after the execution of each delegate (in fact, this is observed in \ u0002 \ u2007 Variables) It ’s easier to use static analysis by using the analyzer. I want to understand static analysis is too tired ... I usually use the common IL instructions, such as ldarg.s, ldc.i4.s, ldloc.s, stloc.s , ldarg.s, call and delegate of branch jump instruction are almost found (the next chapter will talk about the method of analyzing jump instructions)

The next step is to convert the instruction (data) stream to the corresponding IL according to Key, Operand (see BtnVirtualization_Click.vil in the attachment) 
![](https://camo.githubusercontent.com/3037461cc66711bd66092a58575ca7d0c63edc0a/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f56494c2e706e67)
/ * * / is the hexadecimal corresponding to the instruction pointer and the virtualized IL As you can see from the data, the hexadecimal corresponding to each IL instruction is always the same. When reading hexadecimal into key and parameters, don't forget to change the order according to the data type! As for the MethodBase of call and callvirt, it still needs to be obtained through the three breakpoints of the breakpoint recording method.

#### Implementation principle of branch jump

Our advanced IL reduction method has the advantage of being able to analyze branches, so let's talk about the method of analyzing branches: Back to \ u0002 \ u2007. \ U0005 (bool): void is the place of the while loop while the condition of this judgment is this. \ u000F \ u2001 is the sign of return, which means that this. \ u000F \ u2001 = true will be set when the virtual return is executed, so exit the while loop, execute break, exit the for loop that has no effect, and then return step by step according to the call stack .

The if statement is the place to judge the jump. When encountering branch jump statements such as br, btrue, bfalse, ble, blt, bge, bgt, etc., \ u000E \ u2001 will be set as the jump target. \ u000E \ u2001 is a more magical type, uint ?, which is actually Nullable, which is a uint that can be null. When the jump is not needed, keep it null. When the jump is needed, set the instruction pointer \ u0005 \ u2003 to the value of this unit ?. So to analyze the jump, just analyze which function sets \ u000E \ u2001 to non-null. Using the analyzer, only one function is found, that is u0002 (uint): void, it 
![](https://camo.githubusercontent.com/d8b33595fa5ffbdefd9043537e3b7ef4ad36a917/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f75303030322e706e67)
can be seen that it is only responsible for setting the jump instruction, but not Judgment. So you can know that other jump statements will call it, then continue to analyze with the analyzer. 
![](https://camo.githubusercontent.com/15b64929131950921bf224c2cf34a6ef112926b6/68747470733a2f2f6a656d6d796c6f76656a656e6e792e6769746875622e696f2f61727469636c65732f45617a6675736361746f722d416e74692d5669727475616c2d494c2f696d616765732f416e616c797a652d75303030322e706e67)
These are the functions that are equivalent to the IL jump instruction ... and then you need to analyze the function of each function little by little. If you really do not want to analyze, then every time you modify the data on the EvaluationStack (respectively greater than or equal to less than the parameters of the IL instruction), call the same delegate, and see if you jump (see the instruction pointer \ u0005 \ u2003 changes), there is always Way to analyze the jump conditions.

IL instruction backstepping method

Key points:

> Find the position of the while loop and the place where the OpCodesStructure is obtained through Dictionary.TryGetValue (key) and then find the three stacks in this of the virtual machine executor
Determine the type of IL instruction through different delegates of OpCodesStructure or
By observing the change of the stack data and the position of the instruction pointer before and after each step of IL execution, the type and function of this IL are reversely speculated.
Intercept the return value of GetParameters, learn that the parameters of the IL instruction combine the types and parameters, and learn the IL executed at the moment

>Then continue to repeat the above steps until the instruction stream of the entire method is completely restored.

advantage:

> You can get all the information of the instruction stream to make up for the shortcomings of the breakpoint recording method can not judge the branch. Analyze the execution of IL in each step, and the backstepping code is more accurate.

Disadvantages:

> The time-consuming analysis of the equivalent alternative IL delegate makes people vomit, this is manual work ...

However, I think that if you write a program and analyze the Eazfuscator virtualized IL with the IL backstepping method, you can still do it ... because the change of the stack and pointer after each IL instruction is always visible, and the program analyzes each Delegate equivalent replacement IL may be very simple! It should be achievable to reverse the virtual IL stream into a standard IL stream and then convert it to C #. But I will not write .Net shelling tools, maybe a cow like @ wwh1004 can do it ...

### In conclusion
The article mainly introduces two methods for analyzing Eazfuscator.NET virtualized IL protective shell. The basic method breakpoint recording method is relatively simple to operate, but can not determine branch jumps. Advanced method The IL reduction method has high accuracy, but it takes a lot of energy and patience, and it is not very friendly to manual restoration ... It may be better to write auxiliary tools. I have tried my best to make it clear ... I have to read it again and again, if there is still something I can't understand, I can reply to the post and ask me. In fact, there is nothing to summarize, just want to say that writing such a long article, so tired ...



 
